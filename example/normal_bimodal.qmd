---
title: "Normal Bimodal"
author: "Haochu"
format: html
editor: visual
---

```{r}
#| label: load-packages
#| include: false

library(moments)
library(mvtnorm)
library(coda)
library(matrixStats)
library(ggplot2)
library(GGally)
source("../BSL/SL_MCMC.R")
source("../BSL/SL_AM.R")
source("../BSL/SL_SMC.R")
source("../BSL/SL_SMC_CESS.R")
source("../BSL/ESS_weight.R")
source("../BSL/ESS_weight2.R")
source("../BSL/CESS_weight.R")
set.seed(100)
```

## Normal mixture example

We set:
-   $\theta \sim N(0, 9)$,
-   $y|\theta \sim \frac{1}{2}N(\theta, 1) + \frac{1}{2}N(-\theta, 1)$.
Let the true parameter be $\theta = 5$.

```{r}
#| echo: true
x <- seq(-12, 12, length.out = 4000)

prior <- dnorm(x, mean=0, sd=3)
likelihood <- 0.5 * dnorm(x, mean=5, sd=1) +
              0.5 * dnorm(x, mean=-5, sd=1)
posterior_unnorm <- prior * likelihood
posterior <- posterior_unnorm / sum(posterior_unnorm) /
             (x[2] - x[1])

plot(x, prior, type = "l", lwd = 2, col = "blue",
     ylim = c(0, 0.5),
     ylab = "Density",
     xlab = "x",
     main = "Density functions")
lines(x, likelihood, col = "red", lwd = 2, lty = 2)
lines(x, posterior, col = "darkgreen", lwd = 3, lty = 1)
legend("topright",
       legend = c("Prior",
                  "Likelihood",
                  "Posterior"),
       col = c("blue", "red", "darkgreen"),
       lwd = c(2, 2, 3),
       lty = c(1, 2, 1),
       bg = "white")
```

### Sampling and summary statistics

```{r}
#| echo: true
sample_mix_norm <- function(theta = 5, n = 20) {
  u <- runif(n)
  locs <- ifelse(u < 0.5, theta, -theta)
  rnorm(n, mean=locs, sd=1)
}

summary_stats <- function(y) {
  n <- length(y)
  mean_y <- mean(y)
  sd_y <- sd(y)
  mad_y <- mad(y) # median absolute deviation
  skew_y <- moments::skewness(y) # skewness
  kurt_y <- moments::kurtosis(y) - 3 # Pearson kurtosis
  bc <- (skew_y^2 + 1) / (kurt_y + 3*(n-1)^2 / ((n-2)*(n-3))) # bimodality coefficient

  stats_vec <- c(mean_y, sd_y, mad_y, bc)
  return(stats_vec)
}
```

```{r}
#| echo: true
y_obs <- sample_mix_norm()
s_obs <- summary_stats(y_obs)
```

```{r}
#| echo: true
stats_mat <- matrix(NA, nrow=100, ncol=4)
for (i in 1:100) {
  y_iter <- sample_mix_norm(theta=5)
  stats_mat[i, ] <- summary_stats(y_iter)
  if (i %% 10 == 0) {print(paste0("Finish iteration ", i))}
}

stats_df <- as.data.frame(stats_mat)
colnames(stats_df) <- c("mean", "sd", "MAD", "bc")
ggpairs(stats_df)
```

## BSL

Model setup

```{r}
#| echo: true
set.seed(100)
iter <- 50000
init_theta <- rnorm(1, mean=0, sd=3)
prior_func <- function(theta){
  dnorm(theta, mean=0, sd=3, log=TRUE)
}
sample_func <- function(theta, M) {
  s_mat <- matrix(NA, nrow=4, ncol=M)
  for (i in 1:M) {
    z <- sample_mix_norm(theta=theta)
    s_mat[, i] <- summary_stats(z)
  }

  return(list(mean=rowMeans(s_mat),
              sigma=var(t(s_mat))))
}
```

### Find M

```{r}
#| echo: true
M_seq <- seq(5, 100, by=5)
log_likelihood <- rep(NA, length(M_seq))
for (j in 1:length(M_seq)) {
  M <- M_seq[j]
  sl_vec <- rep(NA, 100)
  for (i in 1:100) {
    stats_M <- sample_func(5, M)
    sl_vec[i] <- dmvnorm(x=s_obs,
                         mean=stats_M$mean,
                         sigma=stats_M$sigma,
                         log=TRUE)
  }
  log_likelihood[j] <- var(sl_vec)
  # print(paste0("Finish M = ", M))
}

print(log_likelihood)
M <- M_seq[4]
```

### BSL-MCMC

```{r}
#| echo: true
set.seed(100)
q_sigma <- matrix(9, nrow=1, ncol=1)
theta_seq <- SL_MCMC(M, iter, s_obs, init_theta, prior_func, sample_func,
                     q_sigma, acc_rate=TRUE)
```

```{r}
#| echo: true
plot(1:50000, theta_seq$theta[1, ], type = "l", xlab="Iterations", ylab="Theta")

theta_density <- density(theta_seq$theta[1, 10000:iter])

plot(theta_density,
     main = "Density function",
     xlab = "Theta",
     ylab = "Density",
     col = "black",
     lwd = 2)
```

### BSL-SMC

```{r}
#| echo: true
prior_sampler <- function(){
  rnorm(1, mean=0, sd=3)
}
prior_func <- function(theta){
  dnorm(theta, mean=0, sd=3, log=TRUE)
}
sample_func <- function(theta, M) {
  s_mat <- matrix(NA, nrow=4, ncol=M)
  for (i in 1:M) {
    z <- sample_mix_norm(theta=theta)
    s_mat[, i] <- summary_stats(z)
  }

  return(list(mean=rowMeans(s_mat),
              sigma=var(t(s_mat))))
}

alpha <- 0.9
N <- 1000
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
```

```{r}
#| echo: true
set.seed(100)
theta_smc_c <- SL_SMC_CESS(M, alpha, N, theta_d, s_obs, prior_sampler,
                           prior_func, sample_func, q_sigma,
                           theta_history=TRUE, gamma_history=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_smc_c$gamma)
par(mfrow = c(gamma_n, 1), mar = c(2, 4, 2, 1))
for (i in 1:gamma_n) {
  theta_density <- density(theta_smc_c$theta[1, ,i])
  plot(theta_density,
     main = paste0("Iteration ", i),
     xlab = "Theta",
     ylab = "Density",
     xlim = c(-20, 20),
     col = "black",
     lwd = 2)
}
par(mfrow = c(1, 1))
```

```{r}
#| echo: true
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_smc_c$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_smc_c$ess), type = "l",
     ylim = c(0, exp(theta_smc_c$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_smc_c$cess), type = "l",
     ylim = c(0, exp(theta_smc_c$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

### Adaptive M?

Fix $M = 20$, see how the variance of log-likelihood changes for $\theta \in [-10, 10]$.

```{r}
#| echo: true
var_mat <- rep(NA, 401)
theta_vec <- seq(-10, 10, length.out = 401)
for (j in 1:401) {
  theta <- theta_vec[j]
  sl_vec <- rep(NA, 100)
  for (k in 1:100) {
    stats_M <- sample_func(theta, 20)
    sl_vec[k] <- dmvnorm(x=obs,
                         mean=stats_M$mean,
                         sigma=stats_M$sigma,
                         log=TRUE)
  }
  var_mat[j] <- var(sl_vec)
}
```

```{r}
#| echo: true
plot(theta_vec, var_mat,
     type = "l",
     col = "darkblue",
     xlab = "Theta",
     ylab = "Var(log-likelihood)",
     ylim = range(var_mat),
     lwd = 2)
```

For each iteration in the SMC function. Randomly sample 20 $\theta$s and find the optimal $M$ values from candidates in $seq(5, 100, by=5)$.

```{r}
#| echo: true
opt_M <- matrix(NA, nrow=20, ncol=gamma_n)
M_seq <- seq(5, 100, by=5)
for (i in 1:gamma_n) {
  theta_vec <- sample(theta_smc_c$theta[1, , i], size=20, replace=FALSE)
  for (j in 1:20) {
    theta <- theta_vec[j]
    var_vec <- rep(NA, length(M_seq))
    
    # Find var log-likelihood for different M
    for (l in 1:length(M_seq)) {
      M <- M_seq[l]
      sl_vec <- rep(NA, 100)
      for (k in 1:100) {
      stats_M <- sample_func(theta, M)
      sl_vec[k] <- dmvnorm(x=obs,
                           mean=stats_M$mean,
                           sigma=stats_M$sigma,
                           log=TRUE)
      }
      var_vec[l] <- var(sl_vec)
    }
    
    # Find the optimal M value
    close_M <- which(var_vec <= 3)[1]
    if (is.na(close_M)) {
      opt_M[j, i] <- max(M_seq)
    } else {
      opt_M[j, i] <- close_M
    }
    print(paste0("Finish j = ", j))
  }
  print(paste0("Finish iteration ", i))
}
```

```{r}
#| echo: true
plot(rep(1:gamma_n, each=20), as.vector(opt_M), pch = 4,
     main = "Optimal M values for each iteration in SMC",
     xlab = "Iteration",
     ylab = "M")

# df <- data.frame(
#   Iteration = rep(1:gamma_n, each=20),
#   Opt_M = NA)
# for (i in 1:gamma_n) {
#   r1 <- 1 + 20*(i-1)
#   r2 <- 20*i
#   df$Opt_M[r1:r2] <- opt_M[, i]
# }
# boxplot(Opt_M ~ Iteration,
#         data = df,
#         main = "Optimal M values for each iteration in SMC",
#         xlab = "Iteration",
#         ylab = "M",
#         col = rainbow(6),
#         border = "black")
```


