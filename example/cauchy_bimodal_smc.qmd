---
title: "Compare BSL-SMC algorithms with Cauchy bimodal example"
author: "Haochu"
format: html
editor: visual
---

```{r}
#| label: load-packages
#| include: false

library(moments)
library(mvtnorm)
library(coda)
library(matrixStats)
library(ggplot2)
library(future.apply)
source("../BSL/SL_SMC.R")
source("../BSL/SL_SMC_resample.R")
source("../BSL/SL_IBIS.R")
source("../BSL/SL_WF_SMC.R")
source("../BSL/SL_WF_IBIS.R")
source("../BSL/SL_WF_SMC_par.R")
source("../BSL/SL_WF_IBIS_par.R")
source("../BSL/ESS_weight2.R")
source("../BSL/CESS_weight.R")
set.seed(100)
```

## Cauchy mixture example

We set:

-   $\theta \sim Cauchy(0, 1)$,

-   $y|\theta \sim \frac{1}{2}Cauchy(\theta, 1) + \frac{1}{2}Cauchy(-\theta, 1)$.

Let the true parameter be $\theta = 5$.

### Sampling and summary statistics

```{r}
#| echo: true
sample_mix_cauchy <- function(theta = 5, n = 20) {
  u <- runif(n)
  locs <- ifelse(u < 0.5, theta, -theta)
  rcauchy(n, location = locs, scale = 1)
}

summary_stats <- function(y) {
  median_y <- median(y)
  mad_y <- mad(y) # median absolute deviation
  quantile_y <- quantile(y, probs = c(0.25, 0.75))
  median_abs_y <- median(abs(y))
  stats_vec <- c(median_y, mad_y, quantile_y[2] - quantile_y[1], median_abs_y)
  return(stats_vec)
}
```

```{r}
#| echo: true
y_obs <- sample_mix_cauchy()
s_obs <- summary_stats(y_obs)
```

```{r}
#| echo: true
x <- seq(-12, 12, length.out = 4000)
prior <- dcauchy(x, location = 0, scale = 1)

dcauchy_mix <- function(y, theta) {
  0.5 * dcauchy(y, location = -theta, scale = 1) +
  0.5 * dcauchy(y, location =  theta, scale = 1)
}
log_posterior <- function(theta, y) {
  log_prior  <- dcauchy(theta, location = 0, scale = 1, log = TRUE)
  log_like   <- sum(log(dcauchy_mix(y, theta)))
  log_prior + log_like
}
mh_sample <- function(y, n_iter = 50000, proposal_sd = 3) {
  theta <- numeric(n_iter)
  theta[1] <- 0
  
  log_post_curr = log_posterior(theta[1], y)
  
  for (i in 2:n_iter) {
    theta_prop = rnorm(1, theta[i-1], proposal_sd)
    
    log_post_prop = log_posterior(theta_prop, y)
    
    log_alpha = log_post_prop - log_post_curr
    
    if (log(runif(1)) < log_alpha) {
      theta[i] <- theta_prop
      log_post_curr <- log_post_prop
    } else {
      theta[i] <- theta[i-1]
    }
  }
  theta
}

set.seed(100)
theta <- mh_sample(y_obs)
exact_density <- density(theta[10000:50000])
```

```{r}
#| echo: true
plot(exact_density,
     ylim = c(0, 1),
     main = "Density functions",
     xlab = "Theta",
     ylab = "Density",
     col = "black",
     lwd = 2)
lines(x, prior, col = "gray", lwd = 2, lty = 1)
legend("topright",
       c("pi(theta|y_obs)", "pi(theta)"),
       col = c("black", "gray"),
       lty = 1,
       lwd = 2)
```

## BSL

Model setup

```{r}
#| echo: true
prior_sampler <- function(){
  rcauchy(1, location=0, scale=1)
}
prior_func <- function(theta){
  dcauchy(theta, location=0, scale=1, log=TRUE)
}
sample_func <- function(theta, M) {
  s_mat <- matrix(NA, nrow=4, ncol=M)
  for (i in 1:M) {
    z <- sample_mix_cauchy(theta=theta)
    s_mat[, i] <- summary_stats(z)
  }

  return(list(mean=rowMeans(s_mat),
              sigma=var(t(s_mat))))
}
```

### BSL SMC

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
```

```{r}
#| echo: true
set.seed(100)
theta_smc <- SL_SMC(M, alpha, N, theta_d, s_obs, prior_sampler,
                    prior_func, sample_func, q_sigma, AM=TRUE,
                    theta_history=TRUE, gamma_history=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_smc$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_smc$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_smc$ess), type = "l",
     ylim = c(0, exp(theta_smc$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_smc$cess), type = "l",
     ylim = c(0, exp(theta_smc$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

### BSL SMC with resampling at every iteration

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
```

```{r}
#| echo: true
set.seed(100)
theta_smc_r <- SL_SMC_resample(M, alpha, N, theta_d, s_obs, prior_sampler,
                              prior_func, sample_func, q_sigma, AM=TRUE,
                              theta_history=TRUE, gamma_history=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_smc_r$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_smc_r$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_smc_r$ess), type = "l",
     ylim = c(0, exp(theta_smc_r$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_smc_r$cess), type = "l",
     ylim = c(0, exp(theta_smc_r$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

### BSL Iterated Batch Importance Sampling (IBIS)

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
```

```{r}
#| echo: true
set.seed(100)
theta_ibis <- SL_IBIS(M, alpha, N, theta_d, s_obs, prior_sampler,
                      prior_func, sample_func, q_sigma, AM=TRUE,
                      theta_history=TRUE, gamma_history=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_ibis$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_ibis$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_ibis$ess), type = "l",
     ylim = c(0, exp(theta_ibis$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_ibis$cess), type = "l",
     ylim = c(0, exp(theta_ibis$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

## Waste-free SMC

### BSL waste-free SMC (with resampling at every iteration)

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
N_sample <- 10
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
```

```{r}
#| echo: true
set.seed(100)
theta_wf_smc <- SL_WF_SMC(M, alpha, N, N_sample, theta_d, s_obs, prior_sampler,
                          prior_func, sample_func, q_sigma, AM=TRUE,
                          theta_history=TRUE, gamma_history=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_wf_smc$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_wf_smc$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_wf_smc$ess), type = "l",
     ylim = c(0, exp(theta_wf_smc$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_wf_smc$cess), type = "l",
     ylim = c(0, exp(theta_wf_smc$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

### BSL waste-free IBIS

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
N_sample <- 10
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
```

```{r}
#| echo: true
set.seed(100)
theta_wf_ibis <- SL_WF_IBIS(M, alpha, N, N_sample, theta_d, s_obs, prior_sampler,
                            prior_func, sample_func, q_sigma, AM=TRUE,
                            theta_history=TRUE, gamma_history=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_wf_ibis$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_wf_ibis$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_wf_ibis$ess), type = "l",
     ylim = c(0, exp(theta_wf_ibis$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_wf_ibis$cess), type = "l",
     ylim = c(0, exp(theta_wf_ibis$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

## Visualization

```{r}
#| echo: true
plot(exact_density,
     ylim = c(0, 1),
     main = "Density functions",
     xlab = "Theta",
     ylab = "Density",
     col = "black",
     lwd = 2)
lines(x, prior, col = "gray", lwd = 2, lty = 1)
lty_vec <- c(4, 4, 4, 2, 2)
theta_list <- list(theta_smc, theta_smc_r, theta_ibis,
                   theta_wf_smc, theta_wf_ibis)
for (i in 1:5) {
  theta_seq <- theta_list[[i]]
  gamma_n <- length(theta_seq$gamma)
  theta_density <- density(theta_seq$theta[1, ,gamma_n],
                           bw = 0.5,
                           weights = exp(theta_seq$weight[gamma_n, ]))
  lines(theta_density, col = rainbow(5)[i], lwd = 2, lty = lty_vec[i])
}
legend("topright",
       c("BSL-SMC", "BSL-SMC(R)", "BSL-IBIS",
         "BSL-WF-SMC(R)", "BSL-WF-IBIS"),
       col = rainbow(5),
       lty = lty_vec,
       lwd = 2)
```

## Parallel MCMC in waste-free SMC

### BSL waste-free SMC

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
N_sample <- 10
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
plan(multisession, workers = N_sample)
```

```{r}
#| echo: true
set.seed(100)
theta_wf_smc_par <- SL_WF_SMC.par(M, alpha, N, N_sample, theta_d, s_obs,
                                  prior_sampler, prior_func, sample_func,
                                  q_sigma, AM=TRUE, theta_history=TRUE,
                                  gamma_history=TRUE, future_seed=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_wf_smc_par$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_wf_smc_par$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_wf_smc_par$ess), type = "l",
     ylim = c(0, exp(theta_wf_smc_par$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_wf_smc_par$cess), type = "l",
     ylim = c(0, exp(theta_wf_smc_par$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

### BSL waste-free IBIS

```{r}
#| echo: true
M <- 20
alpha <- 0.9
N <- 1000
N_sample <- 10
theta_d <- 1
q_sigma <- matrix(1, nrow=1, ncol=1)
plan(multisession, workers = N_sample)
```

```{r}
#| echo: true
set.seed(100)
theta_wf_ibis_par <- SL_WF_IBIS.par(M, alpha, N, N_sample, theta_d, s_obs,
                                    prior_sampler, prior_func, sample_func,
                                    q_sigma, AM=TRUE, theta_history=TRUE,
                                    gamma_history=TRUE, future_seed=TRUE)
```

```{r}
#| echo: true
gamma_n <- length(theta_wf_ibis_par$gamma)
par(mfrow = c(1, 3))
plot(1:gamma_n, theta_wf_ibis_par$gamma, type = "p",
     xlab = "Iteration",
     ylab = "gamma")
plot(1:gamma_n, exp(theta_wf_ibis_par$ess), type = "l",
     ylim = c(0, exp(theta_wf_ibis_par$ess[1])),
     xlab = "Iteration",
     ylab = "ESS")
plot(1:gamma_n, exp(theta_wf_ibis_par$cess), type = "l",
     ylim = c(0, exp(theta_wf_ibis_par$cess[1])),
     xlab = "Iteration",
     ylab = "CESS")
par(mfrow = c(1, 1))
```

## Time and efficiency

```{r}
#| echo: true
df_eff <- readRDS("../df_eff.rds")

df_box <- df_eff
df_box$name <- paste(df_box$move, df_box$run)
df_box$name <- factor(df_box$name,
                      levels = c("std sequential",
                                 "waste-free sequential",
                                 "waste-free parallel"))

ggplot(df_box, aes(x=type, y=time, fill=name)) +
  geom_boxplot() +
  ylab("Time (sec)")
```

```{r}
#| echo: true
eff_compute <- data.frame(method=unique(paste(df_eff$type,
                                              df_eff$move,
                                              df_eff$run)),
                          mean_time=NA,
                          V_QU=NA,
                          V_QL=NA,
                          V_E=NA,
                          V_QU.T=NA,
                          V_QL.T=NA,
                          V_E.T=NA)

for (i in 1:7) {
  mean_time <- mean(df_eff$time[(1+(i-1)*50):(i*50)])
  V_QU <- var(df_eff$QU[(1+(i-1)*50):(i*50)])
  V_QL <- var(df_eff$QL[(1+(i-1)*50):(i*50)])
  V_E <- var(df_eff$E[(1+(i-1)*50):(i*50)])
  
  eff_compute$mean_time[i] <- mean_time
  eff_compute$V_QU[i] <- V_QU
  eff_compute$V_QL[i] <- V_QL
  eff_compute$V_E[i] <- V_E
  eff_compute$V_QU.T[i] <- mean_time * V_QU
  eff_compute$V_QL.T[i] <- mean_time * V_QL
  eff_compute$V_E.T[i] <- mean_time * V_E
}

print(eff_compute)
```















